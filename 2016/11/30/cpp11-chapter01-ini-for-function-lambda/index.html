
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>深入应用C++11之列表初始化/范围for/function/bind/lambda | Fang&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Fang">
    

    
    <meta name="description" content="作者：Frank时间：2016-11-30

上一节讲述了C++中的auto关键字和decltype关键字以及函数模板参数等概念，在本节将继续对C++11中的新特性进行讲述，主要包括列表初始化、范围for语句、function和bind绑定器以及lambda表达式。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入应用C++11之列表初始化/范围for/function/bind/lambda">
<meta property="og:url" content="http://fangrenziwo.com/2016/11/30/cpp11-chapter01-ini-for-function-lambda/index.html">
<meta property="og:site_name" content="Fang's Blog">
<meta property="og:description" content="作者：Frank时间：2016-11-30

上一节讲述了C++中的auto关键字和decltype关键字以及函数模板参数等概念，在本节将继续对C++11中的新特性进行讲述，主要包括列表初始化、范围for语句、function和bind绑定器以及lambda表达式。">
<meta property="og:updated_time" content="2016-12-05T02:59:41.482Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入应用C++11之列表初始化/范围for/function/bind/lambda">
<meta name="twitter:description" content="作者：Frank时间：2016-11-30

上一节讲述了C++中的auto关键字和decltype关键字以及函数模板参数等概念，在本节将继续对C++11中的新特性进行讲述，主要包括列表初始化、范围for语句、function和bind绑定器以及lambda表达式。">

    
    
    <link rel="icon" href="/img/avatar2.png">
    
    
    <link rel="apple-touch-icon" href="/img/avatar.png">
    <link rel="apple-touch-icon-precomposed" href="/img/avatar.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/avatar2.png" alt="Fang&#39;s Blog" title="Fang&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Fang&#39;s Blog">Fang&#39;s Blog</a></h1>
				<h2 class="blog-motto">special for SLAM</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:fangrenziwo.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/30/cpp11-chapter01-ini-for-function-lambda/" title="深入应用C++11之列表初始化/范围for/function/bind/lambda" itemprop="url">深入应用C++11之列表初始化/范围for/function/bind/lambda</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Fang" target="_blank" itemprop="author">Fang</a>
		
  <p class="article-time">
    <time datetime="2016-11-30T07:10:47.000Z" itemprop="datePublished"> 發表於 2016-11-30</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#列表初始化"><span class="toc-number">1.</span> <span class="toc-text">列表初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#列表初始化概念"><span class="toc-number">1.1.</span> <span class="toc-text">列表初始化概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列表初始化的使用细节"><span class="toc-number">1.2.</span> <span class="toc-text">列表初始化的使用细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化列表"><span class="toc-number">1.3.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#防止类型收窄"><span class="toc-number">1.4.</span> <span class="toc-text">防止类型收窄</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基于范围的for循环"><span class="toc-number">2.</span> <span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std-function和bind绑定器"><span class="toc-number">3.</span> <span class="toc-text">std::function和bind绑定器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#可调用对象"><span class="toc-number">3.1.</span> <span class="toc-text">可调用对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可调用对象包装器—std-function"><span class="toc-number">3.2.</span> <span class="toc-text">可调用对象包装器—std::function</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std-bind绑定器"><span class="toc-number">4.</span> <span class="toc-text">std::bind绑定器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda表达式"><span class="toc-number">5.</span> <span class="toc-text">lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda表达式的概念和基本用法"><span class="toc-number">5.1.</span> <span class="toc-text">lambda表达式的概念和基本用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tuple元组"><span class="toc-number">6.</span> <span class="toc-text">tuple元组</span></a></li></ol>
		
		</div>
		
		<p><strong><br>作者：Frank<br>时间：2016-11-30
</strong></p>
<p>上一节讲述了C++中的auto关键字和decltype关键字以及函数模板参数等概念，在本节将继续对C++11中的新特性进行讲述，主要包括列表初始化、范围for语句、function和bind绑定器以及lambda表达式。</p>
<a id="more"></a>
<h1 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h1><h2 id="列表初始化概念"><a href="#列表初始化概念" class="headerlink" title="列表初始化概念"></a>列表初始化概念</h2><p>在C++98/03中，只有两种数据类型可以使用初始化列表，而在C++11中，初始化列表的适用性被大大增加了。它现在可以用于任意类型对象的初始化。其基本示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//ex1</span><br><span class="line">class Foo&#123;</span><br><span class="line">public:</span><br><span class="line">	Foo(int)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	Foo(const Foo&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">	Foo a1(123);</span><br><span class="line">   Foo a2=123; //error &apos;Foo::Foo(const Foo&amp;)&apos; is private</span><br><span class="line">   Foo a3=&#123;123&#125;;</span><br><span class="line">   Foo a4&#123;123&#125;;//a3 a4使用了新的初始化方式来初始化对象</span><br><span class="line">   int a5=&#123;3&#125;;</span><br><span class="line">   int a6&#123;3&#125;;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。而在初始化时，{}前面的等于号是否书写对初始化行为没有影响。在堆上动态分配的数组也可以使用初始化列表进行初始化。列表初始化还可以直接使用在函数的返回值上。</p>
<h2 id="列表初始化的使用细节"><a href="#列表初始化的使用细节" class="headerlink" title="列表初始化的使用细节"></a>列表初始化的使用细节</h2><p>能够使用列表初始化的类型需要满足其为聚合类型，而聚合类型的定义为：</p>
<ul>
<li>类型是一个普通数组；</li>
<li>类型是一个类（class，struct，union），且(1)无用户自定义的构造函数；（2）无私有或保护的非静态数据成员；（3）无基类；（4）无虚函数；（5）不能有{}和=直接初始化的非静态数据成员。</li>
</ul>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>在stl中，容器是通过std::initializer_list这个轻量级的类模板来完成上述功能的。在了解了std::initializer_list之后，再来看看它的一些特点，如下：</p>
<ol>
<li>它是一个轻量级的容器类型，内部定义了iterator等容器必须的概念；</li>
<li>对于std::initializer_list<t>而言，它可以接收任意长度的初始化列表，但要求元素必须是同种类型T（或可转换为T）；</t></li>
<li>它有3个成员接口：size()，begin()，end()；</li>
<li>它只能被整体初始化或赋值；</li>
</ol>
<p>std::initializer_list的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了列表中元素的引用而已。因此，不能这样使用初始化列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::initializer_list&lt;int&gt; func(void)&#123;</span><br><span class="line">	int a=1,b=2;</span><br><span class="line">   return &#123;a,b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：应当总是把std::initializer_list看做保存对象的引用，并在它持有对象的生存期结束之前完成传递。</p>
<h2 id="防止类型收窄"><a href="#防止类型收窄" class="headerlink" title="防止类型收窄"></a>防止类型收窄</h2><p>类型收窄是指导致数据内容发生变化或者精度丢失的隐式类型转换。具体来说，类型收窄包括以下几种情况：</p>
<ol>
<li>从一个浮点数隐式转换为一个整形数，如int i=2.2；</li>
<li>从高精度浮点数隐式转换为低精度浮点数，如从long double隐式转换为double或float；</li>
<li>从一个整形数隐式转换为一个浮点数，并且超过了浮点数的表示范围，如float x=(unsigned long long)-1；</li>
<li>从一个整形数隐式转换为一个长度较短的整形数，并且超出了长度较短的整形数的表示范围，如char x=65536；</li>
</ol>
<p>在C++11中，可以通过列表初始化来检查及防止类型收窄。</p>
<h1 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h1><p>在C++03/98中，不同的容器和数组，遍历的方式不尽相同，写法也不同意，也不够简洁，而C++11基于范围的for循环以统一、简洁的方式来遍历容器和数组。其基本示例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	std::vector&lt;int&gt; arr;</span><br><span class="line">   /// ....</span><br><span class="line">   for(auto it=arr.begin();it!=arr.end();it++)</span><br><span class="line">   		std::cout&lt;&lt;*it&lt;&lt;std::endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，基于范围的for循环的写法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	std::vector&lt;int&gt; arr;</span><br><span class="line">   /// ....</span><br><span class="line">   for(auto n:arr)//使用基于范围for的循环</span><br><span class="line">   		std::cout&lt;&lt;n&lt;&lt;std::endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="std-function和bind绑定器"><a href="#std-function和bind绑定器" class="headerlink" title="std::function和bind绑定器"></a>std::function和bind绑定器</h1><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>在C++中，可调用对象有如下几种定义：</p>
<ul>
<li>是一个函数指针；</li>
<li>是一个具有operator()成员函数的类对象；</li>
<li>是一个可被转换为函数指针的类对象；</li>
<li>是一个类成员指针；</li>
</ul>
<p>在C++11中，定义中的这些对象都被称为可调用对象，相应的，这些对象的类型被称为可调用对象类型。</p>
<h2 id="可调用对象包装器—std-function"><a href="#可调用对象包装器—std-function" class="headerlink" title="可调用对象包装器—std::function"></a>可调用对象包装器—std::function</h2><p>std::function是一个可调用对象的包装器，它是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。通过制定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行。<br>其示例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void func(void)&#123;</span><br><span class="line">	std::cout&lt;&lt;__FUNCTION__&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Foo&#123;</span><br><span class="line">	public:</span><br><span class="line">    static int foo_func(int a)&#123;</span><br><span class="line">    	std::cout&lt;&lt;__FUNCTION__&lt;&lt;&quot;(&quot;&lt;&lt;a&lt;&lt;&quot;)&quot;;</span><br><span class="line">      return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Bar&#123;</span><br><span class="line">	public:</span><br><span class="line">    int operator()(int a)&#123;</span><br><span class="line">    	std::cout&lt;&lt;__FUNCTION__&lt;&lt;&quot;(&quot;&lt;&lt;a&lt;&lt;&quot;)&quot;;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	std::function&lt;void(void)&gt; fr1=func; //绑定一个普通函数</span><br><span class="line">   fr1();</span><br><span class="line">   </span><br><span class="line">   std::function&lt;int(int)&gt; fr2=Foo::foo_func;</span><br><span class="line">   std::cout&lt;&lt;fr2(123)&lt;&lt;std::endl;</span><br><span class="line">   </span><br><span class="line">   Bar bar;</span><br><span class="line">   fr2=bar;//绑定一个仿函数</span><br><span class="line">   std::cout&lt;&lt;fr2(123)&lt;&lt;std::endl;//</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的示例可以看出std::function的使用方法，当给std::function填入合适的函数签名（即一个函数类型，只包括返回值和参数表）之后，它就变成了一个可以容纳所有这一类调用方式的“函数包装器”。std::function可以取代函数指针的作用。因为它可以保存函数延迟执行，所以比较适合作为回调。同样，std::function还可以作为函数入参。其示例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void call_when_even(int x, const std::function&lt;void(int)&gt;&amp; f)&#123;</span><br><span class="line">	if(!(x&amp;1))</span><br><span class="line">    f(x)&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output(int x)&#123;</span><br><span class="line">	std::cout&lt;&lt;x&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	for(int i=0;i&lt;10;i++)</span><br><span class="line">    call_when_even(i,output);</span><br><span class="line">   std::cout&lt;&lt;std::endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h1><p>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。通俗的来讲，它主要有两大作用：</p>
<ol>
<li>将可调用对象与其参数一起绑定成一个仿函数；</li>
<li>将多元（参数个数为n,n&gt;1）可调用对象转换成一元或者(n-1)元可调用对象，即只绑定部分参数；</li>
</ol>
<p>其示例代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void call_when_even(int x, const std::function&lt;void(int)&gt;&amp; f)&#123;</span><br><span class="line">	if(!(x&amp;1))</span><br><span class="line">    f(x)&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output(int x)&#123;</span><br><span class="line">	std::cout&lt;&lt;x&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output_add_2(int x)&#123;</span><br><span class="line">	std::cout&lt;&lt;x+2&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">&#123;</span><br><span class="line">	auto fr=std::bind(output,std::placeholders::_1);</span><br><span class="line">   for(int i=0;i&lt;10;i++)</span><br><span class="line">    call_when_even(i,fr);</span><br><span class="line">   std::cout&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	auto fr=std::bind(output_add_2,std::placeholders::_1);</span><br><span class="line">   for(int i=0;i&lt;10;i++)</span><br><span class="line">    call_when_even(i,fr);</span><br><span class="line">   std::cout&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>std::placeholder::_1是一个占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代；因为有了占位符的概念，std::bind的使用非常灵活，其示例代码如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void output(int x,int y)&#123;</span><br><span class="line">	std::cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	std::bind(output,1,2)();//输出1 2</span><br><span class="line">   std::bind(output,2,std::placeholders::_1)(1);//输出2 1</span><br><span class="line">  	std::bind(output,std::placeholders::_1,2)(1);//输出1 2</span><br><span class="line">   </span><br><span class="line">   std::bind(output,2,std::placeholders::_2)(1);//error 调用时没有第二个参数</span><br><span class="line">   std::bind(output,2,std::placeholders::_2)(1,2);//输出2 2 第一个参数被吞掉了</span><br><span class="line">   </span><br><span class="line">   std::bind(output,std::placeholders::_1,std::placeholders::_2)(1,2);//输出1 2</span><br><span class="line">   std::bind(output,std::placeholders::_2,std::placeholders::_1)(1,2);//输出2 1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面对std::bind的返回结果直接调用。可以看到，std::bind可以直接绑定函数的所有参数，也可以绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders，来决定空位参数将会属于调用发生时的第几个参数。<br>bind还有一个强大之处就是可以组合多个函数。示例如下：<br>假设要找到集合中大于5小于10的元素个数：<br>首先需要一个用来判断是否大于5的功能闭包，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::bind(std::greater&lt;int&gt;(),std::placeholders::_1,10);</span><br></pre></td></tr></table></figure></p>
<p>这里std::bind返回的仿函数只有一个int参数。当输入了这个int参数之后，输入的int值将直接和5进行大小比较，并在大于5时返回true。<br>然后，需要一个判断是否小于10的功能闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::bind(std::less_equal&lt;int&gt;(),std::placeholders::_1,10);</span><br></pre></td></tr></table></figure></p>
<p>有了这两个功能闭包后，只需要用逻辑与把他们连接起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using std::placeholders::_1;</span><br><span class="line">std::bind(std::logical_and&lt;bool&gt;(),std::bind(std::greater&lt;int&gt;(),_1,5),std::bind(std::less_equal&lt;int&gt;(),_1,10);</span><br></pre></td></tr></table></figure></p>
<p>然后就可以符合多个函数/闭包的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using std::placeholders::_1;</span><br><span class="line">auto f=std::bind(std::logical_and&lt;bool&gt;(),std::bind(std::greater&lt;int&gt;(),_1,5),std::bind(std::less_equal&lt;int&gt;(),_1,10);</span><br><span class="line">int count=std::count_if(coll.begin(),coll.end(),f);</span><br></pre></td></tr></table></figure></p>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>lambda表达式是C++11最重要也是最常用的一个特性。其来源于函数编程的概念，也是现代编程语言的一个特点。lambda表达式有如下优点：</p>
<ol>
<li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和维护性；</li>
<li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中在手边的问题，同时也获得了更高的生产率；</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活；</li>
</ol>
<h2 id="lambda表达式的概念和基本用法"><a href="#lambda表达式的概念和基本用法" class="headerlink" title="lambda表达式的概念和基本用法"></a>lambda表达式的概念和基本用法</h2><p>lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda表达式的语法形式可以简单归纳如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，capture是捕获列表，params是参数列表，opt是函数选项，ret是返回值；body是函数体。<br>在C++11中，lambda表达式的返回值是通过前面介绍的返回值后置语法来定义的。因为lambda表达式的返回值很容易被推导，因此在C++11中允许省略其返回值定义。<br>lambda表达式可以通过捕获列表捕获一定范围内的变量：</p>
<ul>
<li>[]不捕获任何变量；</li>
<li>[&amp;]捕获外部作用域中的所有变量，并作为引用在函数体中使用（按引用捕获）；</li>
<li>[=]捕获外部作用域中的所有变量，并作为副本在函数体中使用（按值捕获）；</li>
<li>[=,&amp;foo]按值捕获外部作用域中的所有变量，并按引用捕获foo变量；</li>
<li>[bar]按值捕获bar变量，同时不捕获其他变量；</li>
<li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。捕获this的目的是可以在lambda中使用当前类中的成员函数和成员变量；<br>lambda表达式在C++11中被称为“闭包类型”。它是一个特殊的，匿名的非nunion的类类型。<br>因此，可以认为它是一个带有operator()的类，即仿函数。因此，可以使用std::function和std::bind来存储和操作lambda表达式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;int(int)&gt; f1=[](int a)&#123;return a;&#125;</span><br><span class="line">std::function&lt;int((void)&gt; f2=std::bind([](int a)&#123;return a;&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>没有捕获变量的lambda表达式可以直接转换为函数指针，而捕获变量的lambda表达式则不能转换为函数指针。</p>
<h1 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h1><p>tuple元组是一个固定大小的不同类型值的集合，是泛化的std::pair。其基本使用示例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;const char*,int&gt; tp=make_tuple(sendPack,nSendSize);//构造一个tuple</span><br><span class="line">//其相当于</span><br><span class="line">struct tp&#123;</span><br><span class="line">	char * p;</span><br><span class="line">   int len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto tp=return std::tie(1,&quot;aa&quot;,2);//tp的实际类型是std::tuple&lt;int&amp;,string&amp;,int&amp;&gt;</span><br><span class="line"></span><br><span class="line">//获取tuple的值</span><br><span class="line">const char* data=tp.get&lt;0&gt;();</span><br><span class="line">int len=tp.get&lt;1&gt;();</span><br><span class="line"></span><br><span class="line">//tie解包</span><br><span class="line">int x,y;</span><br><span class="line">string a;</span><br><span class="line">std::tie(x,a,y)=tp;</span><br><span class="line"></span><br><span class="line">//使用std::ignore占位符来表示不解其中某个位置的值</span><br><span class="line">std::tie(std::ignore,std::ignore,y)=tp;</span><br><span class="line"></span><br><span class="line">//创建右值的引用元组</span><br><span class="line">std::map&lt;int,std::string&gt; m;</span><br><span class="line">m.emplace(std::forward_as_tuple(10,std::string(20,&apos;a&apos;)));</span><br><span class="line"></span><br><span class="line">//tuple_cat连接多个tuple</span><br><span class="line">std::tuple&lt;int,std::string,float&gt; t1(10,&quot;Test&quot;,3.14);</span><br><span class="line">int n=7;</span><br><span class="line">auto t2=std::tuple_cat(t1,std::make_pair(&quot;Foo&quot;,&quot;bar&quot;),t1,std::tie(n));</span><br><span class="line">n=10;</span><br><span class="line">print(t2);//输出(10,Test,3.14,Foo,bar,10,Test,3.14,10)</span><br></pre></td></tr></table></figure></p>
<p>tuple虽然可以用来代替简单的结构体，但不要滥用，如果使用tuple来替代3个以上字段的结构体时就不太合适了，因为使用tuple会使得代码的易读性降低。</p>
 <center><br><strong><br>转载请注明出处
</strong><br></center>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C-11/">C++11</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C-11理论/">C++11理论</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://fangrenziwo.com/2016/11/30/cpp11-chapter01-ini-for-function-lambda/" data-title="深入应用C++11之列表初始化/范围for/function/bind/lambda | Fang&#39;s Blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/12/06/cpp11-chapter02-rvalue-forward-move-unordered/" title="深入应用C++11之使用C++11改进程序性能">
  <strong>上一篇：</strong><br/>
  <span>
  深入应用C++11之使用C++11改进程序性能</span>
</a>
</div>


<div class="next">
<a href="/2016/11/25/cpp11-chapter01-auto-decltype-using/"  title="深入应用C++11之auto、decltype和模板别名">
 <strong>下一篇：</strong><br/> 
 <span>深入应用C++11之auto、decltype和模板别名
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/11/30/cpp11-chapter01-ini-for-function-lambda/" data-title="深入应用C++11之列表初始化/范围for/function/bind/lambda" data-url="http://fangrenziwo.com/2016/11/30/cpp11-chapter01-ini-for-function-lambda/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#列表初始化"><span class="toc-number">1.</span> <span class="toc-text">列表初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#列表初始化概念"><span class="toc-number">1.1.</span> <span class="toc-text">列表初始化概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列表初始化的使用细节"><span class="toc-number">1.2.</span> <span class="toc-text">列表初始化的使用细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化列表"><span class="toc-number">1.3.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#防止类型收窄"><span class="toc-number">1.4.</span> <span class="toc-text">防止类型收窄</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基于范围的for循环"><span class="toc-number">2.</span> <span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std-function和bind绑定器"><span class="toc-number">3.</span> <span class="toc-text">std::function和bind绑定器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#可调用对象"><span class="toc-number">3.1.</span> <span class="toc-text">可调用对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可调用对象包装器—std-function"><span class="toc-number">3.2.</span> <span class="toc-text">可调用对象包装器—std::function</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std-bind绑定器"><span class="toc-number">4.</span> <span class="toc-text">std::bind绑定器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda表达式"><span class="toc-number">5.</span> <span class="toc-text">lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda表达式的概念和基本用法"><span class="toc-number">5.1.</span> <span class="toc-text">lambda表达式的概念和基本用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tuple元组"><span class="toc-number">6.</span> <span class="toc-text">tuple元组</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/C-11/" title="C++11">C++11<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/SLAM移植/" title="SLAM移植">SLAM移植<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/SLAM系列/" title="SLAM系列">SLAM系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/计算机视觉/SLAM系列/" title="SLAM系列">SLAM系列<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/SLAM资源/" title="SLAM资源">SLAM资源<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/计算机视觉/" title="计算机视觉">计算机视觉<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/C-11理论/" title="C++11理论">C++11理论<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/SLAM/" title="SLAM">SLAM<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/计算机视觉/" title="计算机视觉">计算机视觉<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/链接/" title="链接">链接<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/干货/" title="干货">干货<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/非线性优化/" title="非线性优化">非线性优化<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/特征检测/" title="特征检测">特征检测<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/test/" title="test">test<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/相机姿态/" title="相机姿态">相机姿态<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/图像处理理论/" title="图像处理理论">图像处理理论<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/回环检测/" title="回环检测">回环检测<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Android-Studio/" title="Android Studio">Android Studio<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="http://blog.csdn.net/zf19921020" target="_blank" title="我的CSDN">我的CSDN</a>
            
          </li>
        
          <li>
            
            	<a href="http://wantedonline.cn" target="_blank" title="技术家园">技术家园</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.slamcn.org" target="_blank" title="SLAMCN">SLAMCN</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 业精于勤荒于嬉，行成于思毁于随 <br/>
			热爱计算机视觉，热爱Coding...</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/FangGet" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:buptzhaofang@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Fang">Fang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"fangrenziwo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
